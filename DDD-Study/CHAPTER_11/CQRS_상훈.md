### 단일모델의 단점
> 주문 내역 조회 기능 사용 시 필요한 정보 예시
>   * Order 주문정보 
>   * Product  상품 이름
>   * Member 회원이름과 ID
 
 조회 구현 방식 고민이 필요
 1. `(2)식별자를 이용`해서 애그리거트를 참조하는 방식 -> 즉시 로딩(eager loading)방식과 같은 JPA의 쿼리 관련 최적화 기능 사용 못함
   -> `한 번의 select 쿼리로 조회 화면에 필요한 데이터를 읽어올 수 없어 조회 성능에 문제?`
     * 참고 - `(3)JPA를 사용`하면 참조한 객체를 지연로딩과 즉시로딩의 두 가지 방식으로 로딩할 수 있다
       * 즉시로딩 : 단순히 연관된 객체의 데이터를 함께 화면에 보여줘야 하면 즉시로딩 (조회)
       * 지연로딩 : 애그리거트의 상태를 변경하는 기능을 실행하는 경우, 불필요한 객체를 함께 로딩하지 않는다 (상태변경)
   ```java
   
   ```
 2. 애그리거트 간 연관을 식별자가 아니라 `(1)직접 참조 하는 방식`으로 연결
 -> 조회 화면 특성에 따라 같은 연관도 즉시 로딩이나 지연 로딩으로 처리해야 하기 때문
    * DBMS가 제공하는 전용 기능이 필요하면 `JPA의 네이티브 쿼리?`를 사용해야 할 수도
 
 * 고민이 발생하는 이유 -> 시스템 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문
   * ORM 기법은 도메인 상태 변경 기능을 구현하는데는 적합하나, 여러 애그리거트에서 데이터를 가져와 출력하는 (조회)기능을 구현하기에는 고려할 게 많아서 구현을 복잡하게 만드는 원인이 된다.
   * 따라서, 상태 변경 모델과 조회를 위한 모델을 분리함으로써 위 문제를 해소할 수 있다.
### CQRS 
 * 상태 변경의 범위 : 보통 한 애그리거트
 * 조회의 범위 : 보통 여러 애그리거트
 * 상황 : 범위의 불일치 
 * 단일모델로 두 기능을 구현하면 모델이 복잡해짐 -> 그래서 필요한 것이 CQRS 패턴
 * CQRS(Command Query Responsibility Segregation) : 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴
 * 명령 모델과 조회 모델은... 
   * 구현 기술 관점
     * 서로 다른 기술을 이용해서 구현 : JPA(상태변경), Mybatis(조회)
     * 같은 구현 기술을 이용해서 구현 : JPQL을 이용한 동적 인스턴스 생성, 하이버네이트의 @Subselect
   * 데이터 저장소 관점
     * RDBMS(상태변경)
     * 조회 성능이 좋은 메모리 기반 NoSQL(조회)
     * 두 데이터 저장소 간 데이터 동기화는 이벤트를 활용해서 처리
##### 웹과 CQRS
* 웹 서비스에서는 상태변경 요청 < 상태를 조회하는 요청
* 조회 성능을 위해..
  * 쿼리를 최적화 -> 쿼리 실행 속도 up 
  * 메모리에 조회 데이터를 캐싱 -> 응답 속도 up -> <br>
    => 보관된 데이터를 그대로 저장하는 것이 아니라 화면에 맞는 모양으로 변환한 데이터를 캐싱 -> 조회 전용 모델을 캐싱 <br>
    => 결국 조회 성능을 높이기 위해 하는 다양한 기법을 사용하는 효과 => CQRS를 적용한 효과
##### CQRS 장단점
* 장점
  * 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다
  * 조회 관련 로직이 사라져 복잡도가 낮아짐
  * 조회 성능을 향상시키는 데 유리
* 단점
  * 구현해야 할 코드가 더 많다 -> 단일 모델 시 복잡함에서 나오는 비용과 조회 전용 모델을 구현 시 나오는 비용을 비교해보아야한다
  * 더 많은 구현 기술이 필요
애그리거트
==


개발할때 상위 수준 개념을 이용해서 전체모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다.

>Q1) 두 개 이상의 애그리거트를 변경해야 하면, 응용 서비스에서 각 애그리거트의 상태를 변경한다.<br>
> 애그리거트의 메서드에서 다른 애그리거트의 상태를 변경하는 것이 아닌 기능을 구현한 서비스에 상태변경의 역할이 담긴 메서드를 통해 변경해서 한다는 내용이 맞을까?


객체의 영속성을 처리하는 repository는 aggregate 단위로 존재함. <br>
물리적으로 별도의 DB 테이블이지만 repository를 각각 만들지는 않음.

>Q2) 두 개의 물리적으로 다른 테이블을 한개의 애그리거트를 통해 저장한다면, 반드시 2개의 테이블의 데이터를 새로 저장하는 거라고 보게된다? 
> 
> 

필드를 이용한 애그리거트 참조는 여러 문제를 야기함
* 편한 탐색 오용
* 성능에 대한 고민(?)
* 확장 어려움

한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.

애그리거트 루트로 참조가 아닌 ID를 이용해 간접참조를 하자. -> 애그리거트 간의 의존 제거 및 응집도를 높여줌

ID로 애그리거트를 참조하면 repository마다 다른 저장소를 사용하도록 구현할 때 확장이 용이함.

setter 메소드 대신 change 메소드(의미있는, 인지할 만한 용어)를 사용하는 건 약간의 눈속임 이지만 간접적으로 변경해주는 형태의 메소드 명명을 해보도록 하자.
-> 객체에게 기능 수행을 시킨다는 의미의 Naming이 필요함. 능동적인 객체.

유저가 자체적으로 동작할 수 없는 동작을 도메인 서비스로 만들어 사용하자.<br>
e.g) user duplicate method();

도메인 객체에서 Factory는 재사용성에 focus.

객체의 관점에서 상태는 Field.

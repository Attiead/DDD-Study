아키텍쳐
=

MVC의 전형적인 영역 : 표현, 응용, 도메인, 인프라스트럭처<br/>

응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.<br>

>응용 영역은 도메인 모델을 이용해서 사용자에게 제공할 기능을 구현한다.
> 실제 도메인 로직 구현은 도메인 모델에 위임한다.

도메인 영역은 도메인 모델을 구현한다.<br>
도메인 모델은 도메인의 핵심 로직을 구현한다.<br>
e.g)주문 도메인의 배송지 변경, 결제 완료 등 핵심 로직을 구현

인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다.<br>
RDBMS 연동, 메세징 큐, 레디스, SMTP, HTTP Client<br>
Config의 성격이라고 봐도 되는 것일까


DIP 
--
도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다.


구성요소
--
Entity : 고유 식별자를 갖는 객체로 라이프사이클이 있음 e.g)주문, 회원, 상품<br>
Value : 식별자를 가지지 않음 -> 엔티티의 속성으로 사용 e.g)주소, 금액<br>
Aggregate : 연관된 Entity&Value e.g)주문 : Order, OrderLine&Orderer(vo)<br>
Repository : 도메인 모델의 영속성 처리<br>
Domain Service : 특정 엔티티데 속하지 않은 도메인 로직. 여러 엔티티와 밸류로 이루어진 기능.

Aggregate : 객체를 하나로 묶은 군집<br>
--
e.g) 주문 : 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액 의 하위 모델로 구성 -> 묶어서 상위 개념인 주문으로 표현함.

애그리거트를 구현할 때는 고려할 것이 많다. 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고, 트랜잭션 범위가 달라지기도 한다. 또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.

애그리거트의 루트식별자 : e.g) 주문번호?

Repository : DB, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관한 도메인 모델
--
Repository는 Aggregate단위로 도메인 객체를 저장하고 조회하는 기능을 정의함.
> JPA의 Repository를 사용할 때 객체를 이용해서 사용했었다. <br>
> 비슷한 형태로 사용이 되지만 다루는 객체를 부르는 명청이 특정상황에 따라 Value or Aggregate로 변경되는 것 같다.

> 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술의 영향을 받는다.

인프라스트럭처
--
무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없다. 
> 구현의 편리함은 DIP가 주는 다른 장점(변경의 유연함, 테스트가 쉬움)만큼 중요하기 때문에 DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 나쁘지 않다.
> e.g) @Transactional -> 한줄이 여러줄의 코드생산을 만들고 더 복잡해진다.


모듈
--

> 한 패키지에 가능하면 10~15개 미만으로 타입 개수를 유지하려고 노력한다. 이상이 되면 분리하는 시도를 해보자.
 
 
 
상위 domain - ui - application - 중위 domain - (aggregate1, aggregate2...) - infrastructure
--
### 도메인 모델과 경계
* 이해
  >> 한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에 한 개의 모델로 여러 하위 모메인을 모두 표현하려고 시도하면
       오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.
  > * 예
  > * 모델 : 상품 (카탈로그에서 '상품', 재고 관리에서 '상품', 주문에서 '상품', 배송에서 '상품')
  > * 이름만 같지 실제로 의미하는 것이 다름.
  > * ##### 논리적으로는 같으나 물리적으로 다름
  >   * 카탈로그에서 '상품' -> 상품 정보가 위주 -> `한 개`
  >   * 재고 관리에서 '상품' -> 실존하는 개별 객체를 추적하기 위한 목적 -> `여려 개`
  > * ##### 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우
  >   * 카탈로그 도메인에서 '상품'이 검색 도메인에서는 '문서'라고 불리기도
  >   * 시스템을 이용하는 `'사람'` -> 회원 도메인에서는 `'회원'`, 주문 도메인에서는 `'주문자'`
  >   * Q. 그럼 회원, 주문 도메인이 `하위 도메인`이고 상품 도메인이 `상위 도메인`다 ??

  >> 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다.
  > * 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
  > * 서로 얽히면 각 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워지기 때문.
  > * 모델은 특정한 컨텍스트(문맥) 하에서 완전한 의미를 갖는다.
  > * 결론 : 구분되는 경계를 갖는 컨텍스트가 필요하고, DDD에서는 이를 `바운디드 컨텍스트(Bounded Context)`라고 부른다.
  
### 바운디드 컨텍스트
* 구현 방향
  * 바운디드 컨텍스트는 용어를 기준으로 구분한다
    * `카탈로그` 컨텍스트와 `재고` 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다.
  * 바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 `물리적 시스템`으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.
  >> 바운디드 컨텍스트는 기업의 팀 조직 구조에 따라 결정되기도 한다.
  > * 예
  > * `주문 하위 도메인`이라도 `주문을 처리하는 팀`과 `복잡한 결제 금액 계산 로직을 구현하는 팀`
  >   * 나누는 경우 : `주문 하위 도메인`에 `주문 바운디드 컨텍스트`와 `결재 금액 계산 바운디드 컨텍스트'가 존재하게 됨.
  >   * 나누지 않는 경우 : 카탈로그와 재고 관리가 아직 명확하게 구분되지 않은 경우 '상품 바운디드 컨텍스트'
  > * 주의할 점 : 하나의 바운디드 컨텍스트인 경우 하위 도메인의 모델이 섞이지 않아야 한다.
  >   * 이유 : 결과적으로 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해서 하위 도메인별로 기능을 확장하기 어렵게 되고 이는 서비스의 경쟁력을 떨어뜨리게 됨.
  >   * 해결책 : 하위 도메인마다 구분되는 `패키지`를 갖도록 구현
  > * 회원의 Member는 애그리거트 루트지만 주문의 Orderer는 밸류가 되고 카탈로그의 Product는 상품이 속한 Category와 연관을 갖지만,
  > 재고의 Product는 카탈로그의 Category와 연관을 맺지 않는다.
  
### 바운디드 컨텍스트 구현
* 확장
  >> 바운디드 컨텍스트는 `도메인 모델만 포함하는 것이 아니라`, 
  >> 도메인 기능을 사용자에게 제공하는 데 필요한 `표현 영역`, `응용 서비스`, `인프라스트럭처 영역`,
  >> 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 `테이블`도 포함한다.
  > * 스키마
  >   * 데이터베이스 스키마는 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조.
  >   * 데이터베이스 관리 시스템이 주어진 설정에 따라 데이터베이스 스키마를 생성
  >   * 데이터베이스 사용자가 자료를 저장, 조회, 삭제, 변경할 때 DBMS는 자신이 생성한 데이터베이스 스키마를 참조하여 명령을 수행함.
  >> 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.
  > * 상품의 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 CRUD 방식으로 구현해도 된다.
  > * 즉 DAO와 데이터 중심의 밸류 객체를 이용해서 리뷰기능을 구현해도 기능을 유지 보수하는데 큰 문제가 없다.
  > * 저자 생각 : 도메인 계층이 없으면, 도메인 기능이 서비스에 흩어지게 되지만 그 기능 자체가 단순하면 서비스-DAO로 구성된 CRUD 방식을 이용해도 코드를 유지보수하는데 문제가 되지 않는다
  >> 한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용
  > * CQRS 패턴 (Command Query Responsibility Segregation)
  > * `상태를 변경하는 명령 기능`과 `내용을 조회하는 쿼리 기능`을 위한 `모델을 구분`하는 패턴
  > * 상태를 변경하는 명령 기능 : 도메인 모델 기반으로 구현(도메인주도 개발)
  > * 조회 기능 : 서비스-DAO를 이용해서 구현
  >> 각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다.
  > * 예
  >     * A 바운디드 컨텍스트 -> 웹 MVC : 스프링 MVC 사용, 리포지터리 구현 : JPA/하이버네이트
  >     * B 바운디드 컨텍스트 -> Rest API : Netty 사용, 리포지터리 구현 : 마이바티스
  >> 바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니다
  > * 제품 상세 페이지에서 리뷰 목록을 'Ajax' 요청 시 'JSON' 응답하는 경우
  > * UI 서버에서 바운디드 컨텍스트와 통신해서 사용자 요청을 처리하는 경우
  >   * UI 서버는 각 바운디드 컨텍스트를 위한 파사드 역할을 수행.
  >     * 카탈로그와 리뷰 바운디드 컨텍스트로부터 필요한 정보를 읽어와 조합한 뒤 브라우저에 응답을 제공.
  >     * 파사드 패턴 : 일련의 저수준 인터페이스들을 하나의 고수준 인터페이스로 묶어주는 패턴

### 바운디드 컨텍스트 간 통합
* 통합의 필요성
  * 카탈로그 하위 도메인에 개인화 추천 기능을 추가 하기 위해, 별도의 팀이 새로 생겨, 이 팀이 주도적으로 추천 시스템을 만들기로 함
  * 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생김.
  * 필요 기능 : 사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다.
### 도메인 모델과 경계
* 이해
  >> 한 도메인은 다시 여러 하위 도메인으로 구분되기 때문에 한 개의 모델로 여러 하위 모메인을 모두 표현하려고 시도하면
       오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.
  > * 예
  > * 모델 : 상품 (카탈로그에서 '상품', 재고 관리에서 '상품', 주문에서 '상품', 배송에서 '상품')
  > * 이름만 같지 실제로 의미하는 것이 다름.
  > * ##### 논리적으로는 같으나 물리적으로 다름
  >   * 카탈로그에서 '상품' -> 상품 정보가 위주 -> `한 개`
  >   * 재고 관리에서 '상품' -> 실존하는 개별 객체를 추적하기 위한 목적 -> `여려 개`
  > * ##### 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우
  >   * 카탈로그 도메인에서 '상품'이 검색 도메인에서는 '문서'라고 불리기도
  >   * 시스템을 이용하는 `'사람'` -> 회원 도메인에서는 `'회원'`, 주문 도메인에서는 `'주문자'`
  >   * Q. 그럼 회원, 주문 도메인이 `하위 도메인`이고 상품 도메인이 `상위 도메인`다 ?? 나누는 기준은?? 더 추상적인 것이 상위인 것일까?

  >> 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다.
  > * 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
  > * 서로 얽히면 각 하위 도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워지기 때문.
  > * 모델은 특정한 컨텍스트(문맥) 하에서 완전한 의미를 갖는다.
  > * 결론 : 구분되는 경계를 갖는 컨텍스트가 필요하고, DDD에서는 이를 `바운디드 컨텍스트(Bounded Context)`라고 부른다.
  
### 바운디드 컨텍스트
* 구현 방향
  * 바운디드 컨텍스트는 용어를 기준으로 구분한다
    * `카탈로그` 컨텍스트와 `재고` 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다.
  * 바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 `물리적 시스템`으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.
  >> 바운디드 컨텍스트는 기업의 팀 조직 구조에 따라 결정되기도 한다.
  > * 예
  > * `주문 하위 도메인`이라도 `주문을 처리하는 팀`과 `복잡한 결제 금액 계산 로직을 구현하는 팀`
  >   * 나누는 경우 : `주문 하위 도메인`에 `주문 바운디드 컨텍스트`와 `결재 금액 계산 바운디드 컨텍스트'가 존재하게 됨.
  >   * 나누지 않는 경우 : 카탈로그와 재고 관리가 아직 명확하게 구분되지 않은 경우 '상품 바운디드 컨텍스트'
  > * 주의할 점 : 하나의 바운디드 컨텍스트인 경우 하위 도메인의 모델이 섞이지 않아야 한다.
  >   * 이유 : 결과적으로 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해서 하위 도메인별로 기능을 확장하기 어렵게 되고 이는 서비스의 경쟁력을 떨어뜨리게 됨.
  >   * 해결책 : 하위 도메인마다 구분되는 `패키지`를 갖도록 구현
  > * 회원의 Member는 애그리거트 루트지만 주문의 Orderer는 밸류가 되고 카탈로그의 Product는 상품이 속한 Category와 연관을 갖지만,
  > 재고의 Product는 카탈로그의 Category와 연관을 맺지 않는다.
  
### 바운디드 컨텍스트 구현
* 확장
  >> 바운디드 컨텍스트는 `도메인 모델만 포함하는 것이 아니라`, 
  >> 도메인 기능을 사용자에게 제공하는 데 필요한 `표현 영역`, `응용 서비스`, `인프라스트럭처 영역`,
  >> 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 `테이블`도 포함한다.
  > * 스키마
  >   * 데이터베이스 스키마는 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조.
  >   * 데이터베이스 관리 시스템이 주어진 설정에 따라 데이터베이스 스키마를 생성
  >   * 데이터베이스 사용자가 자료를 저장, 조회, 삭제, 변경할 때 DBMS는 자신이 생성한 데이터베이스 스키마를 참조하여 명령을 수행함.
  >> 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.
  > * 상품의 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 CRUD 방식으로 구현해도 된다.
  > * 즉 DAO와 데이터 중심의 밸류 객체를 이용해서 리뷰기능을 구현해도 기능을 유지 보수하는데 큰 문제가 없다.
  > * 저자 생각 : 도메인 계층이 없으면, 도메인 기능이 서비스에 흩어지게 되지만 그 기능 자체가 단순하면 서비스-DAO로 구성된 CRUD 방식을 이용해도 코드를 유지보수하는데 문제가 되지 않는다
  >> 한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용
  > * CQRS 패턴 (Command Query Responsibility Segregation)
  > * `상태를 변경하는 명령 기능`과 `내용을 조회하는 쿼리 기능`을 위한 `모델을 구분`하는 패턴
  > * 상태를 변경하는 명령 기능 : 도메인 모델 기반으로 구현(도메인주도 개발)
  > * 조회 기능 : 서비스-DAO를 이용해서 구현
  >> 각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다.
  > * 예
  >     * A 바운디드 컨텍스트 -> 웹 MVC : 스프링 MVC 사용, 리포지터리 구현 : JPA/하이버네이트
  >     * B 바운디드 컨텍스트 -> Rest API : Netty 사용, 리포지터리 구현 : 마이바티스
  >> 바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니다
  > * 제품 상세 페이지에서 리뷰 목록을 'Ajax' 요청 시 'JSON' 응답하는 경우
  > * UI 서버에서 바운디드 컨텍스트와 통신해서 사용자 요청을 처리하는 경우
  >   * UI 서버는 각 바운디드 컨텍스트를 위한 파사드 역할을 수행.
  >     * 카탈로그와 리뷰 바운디드 컨텍스트로부터 필요한 정보를 읽어와 조합한 뒤 브라우저에 응답을 제공.
  >     * 파사드 패턴 : 일련의 저수준 인터페이스들을 하나의 고수준 인터페이스로 묶어주는 패턴

### 바운디드 컨텍스트 간 통합
* 통합의 필요성
  * 카탈로그 하위 도메인에 개인화 추천 기능을 추가 하기 위해, 별도의 팀이 새로 생겨, 이 팀이 주도적으로 추천 시스템을 만들기로 함
  * 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생김.
  * 필요 기능 : 사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다.
  ```java
  //도메인 관점에서 인터페이스 정의 (도메인 영역)
  public interface ProductRecommendationService() {
    List<Product> getRecommendationOf(ProductId id);
  }
  //도메인 서비스를 구현한 클래스 (인프라스트럭쳐 영역)
  public class RecSystemClient implements ProductRecommendationService{
    private ProductRepository productRepository;
    
    @Override 
    public List<Product> getRecommendationOf(ProductId id){
        List<RecommendationItem> items = getRecItems(id.getValue());
        return externalRecClient.getRecs(itemId);
    }
  
    private List<RecommendationItem> getRecItems(String itemId){
        // externalRecClient는 외부 추천 시스템에 연결할 때 사용하는 클라이언트라고 가정
        return externalRecClient.getRecs(itemId);
    }
  
    private List<Product> toProducts(List<RecommendationItem> items) {
        return items.stream()
                    .map(item -> toProductId(item.getItemId()))
                    .map(prodId -> productRepository.findById(prodId))
                    .collect(toList());
    } 
  
    private ProductId toProductId(String itemId) {
        return new ProductId(itemId);
    }
  }
  ```
### 바운디드 컨텍스트 간 관계  
* 관계 형태
  * 한쪽에서 API를 제공하고 다른 한 쪽에서 그 API를 호출하는 관계 (REST API) 사용하는 쪽이 제공하는 쪽에 의존.
  * 카탈로그 바운디드 컨텍스트 (하류) -----고객/공급자 관계----- (상류) 추천 바운디드 컨텍스트
  * 카탈로그 바운디드 컨텍스트가 추천 바운디드 컨텍스트를 의존.
  * 상류 컴포넌트는 일종의 서비스 공급자 역할
  * 하류 컴포넌트는 그 서비스를 사용하는 고객 역할
>> 상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개함
> * 추천시트템은 하류 컴포넌트가 사용할 수 있는 `REST API를 제공`하거나, `프로토콜 버퍼`와 같은 것을 이용해서 서비스를 제공할 수 있다.
>   * 프로토콜 버퍼???
>  ```json
>      // person 객체
>   {   
>     "userName" : "Martin",
>     "favoriteNumber : 1337,
>     "interests" : ["daydreaming", "hacking"]
>   }
>  ```
>   ```text
>   // person 객체에 대한 프로토콜 버퍼 스키마
>   // 이 스키마로 위의 데이터를 인코딩
>     message Person {
>    requred string user_name       =1;
>    optional int64 favorite_number =2;
>    repeated string interests      =3;
>   }
>   ```
> * 상류팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류팀의 요구 사항을 수용할 수 있는 API를 만들고, 이를 서비스 형태로 공개해서 서비스의 일관성을 유지 (공개 호스트 서비스)
> * ex. 검색 ( 블로그, 카페, 게시판과 같은 서비스에 개별적으로 검색 기능을 구현하기 보다는 검색을 위한 전용 시스템을 구축하고, 검색 서비스와 각 서비스를 통합)
> * 상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다.
> * `안티코럽션 계층` : 외부 시스템과의 연동으로, 외부 시스템의 도메인 모델이 내 도메인 모델을 침범하지 않도록 막아주는 역할을 하는 부분
> * `공유 커널` : 두 바운디드 컨텍스트가 모델이 같은 경우, 중복 설계를 막기 위해 공유.
> * `독립 방식` : 두 바운디드 컨텍스트 간의 통합이 수동으로 이루어지는 경우
>   * 쇼핑몰 운영 + 외부 ERP 서비스 사용
>   * 쇼핑몰 운영자는 쇼핑몰 시스템에서 판매 정보를 보고 ERP 시스템에 입력해야 함.
>   * 수동으로 통합할 경우 규모가 커질 수록 한계가 있다. -> 통합해주는 별도의 시스템이 필요
>   * 쇼핑몰 바운디드 컨텍스트 -----(판매정보로딩)-----통합시스템-----(ERP에 입력)-----외부 ERP 바운디드 컨텍스트   

### 컨텍스트 맵
* 바운디드 컨텍스트 간의 관계를 표시하여, 조망할 수 있는 지도. 시스템의 전체 구조를 보여줌
* 오픈 호스트 서비스(OHS)
* 안티코럽션 계층(부패 방지 계층, ACL)
* 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텍스트를 조절
* 사업의 핵심 도메인을 위해 조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는데 도움을 줌
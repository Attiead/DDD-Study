### 애그리거트와 트랜잭션
> 한 주문 애그리거트에 대해 운영자는 배송 상태로 변경할 때 사용자는 배송지 주소를 변경하면 어떻게 될까?
* 생각해보자
  * 주문 애그리거트의 상태 변경이 일어난다.
  * 배송 상태로 변경 하려면 결제가 이루어져야 한다.
  * 결제 후에도 배송지 주소를 변경하게 하면 상태 변경이 수시로 일어날 수 있어 지양하는 것이 좋을 듯 하다.
  * 책에서는 `운영자가 하는 배송 상태 변경`과 `사용자가가 하는 배송지 주소 변경`이 동시에 이루어지는 상황에
  대처를 어떻게 해야 하는지에 대해 묻는 듯 하다.
  * 동시변경일 경우 상태의 일관성이 깨지는 것 아닌가?
  * 일관성이 깨지지 않게 하기 위해선 애그리거트 루트를 이용하자라는 생각에서 저자가 던진 걸까?

> 트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로, 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.
* 생각해보자
  * 트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위.
  * 트랙잰션의 상태
    * Active : 트랜잭션이 실행중인 상태
    * Failed : 트랜잭션 실행에 오류가 발생하여 중단된 상태
    * Aborted : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
    * Partially Committed : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
    * Committed : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태.
  * `Q. 왜 리포지터리는 트랜잭션마다 새로운 애그리거트 객체를 생성할까?`
    * 차라리 동시에 생성된 서로 다른 스레드가 논리적으로 같은 애그리거트를 거치기 때문에 서로 다른 객체가 생성된다 <br>
    라고 생각하는 것이...
    * 밸류 객체가 불변이면 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것과 관련이 있나?
    * 스레드가 달라서 새로운 객체 생성이 된다는 의미 인건가?
> 일관성이 깨지는 문제가 발생하지 않도록 하려면 다음 두 가지 중 하나를 해야함
> * 선점 잠금 (Pessimistic Lock) / 비관적 잠금
>   * 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다
> * 비선점 잠금 (Optimistic Lock) / 낙관적 잠금
>   * 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

### 선점 잠금
* 이해
  * 어떤 스레드가 애그리거트를 먼저 구하면, 해당 애그리거트에 접근을 잠금고 상태 변경 이후 트랜잭션 커밋을 하면 잠금을 해제한다.
  * 잠금 상태 일때 다른 스레드는 대기 상태이고, 잠금 해제로 블로킹이 해제되면 상태가 변경 된 애그리거트에 접근하게 된다.
  * 구현
    * 행단위 잠금을 사용
      * ex. `for update와 같은 쿼리를 사용해서 특정 레코드에 한 커넥션만 접근할 수 있는 잠금 장치를 제공한다.`
      >   SELECT * <br>
         FROM 테이블 <br>
         WHERE ID = '1111' <br>
         FOR UPDATE (옵션) 
      >   * no option : lock을 획득하기 까지 무한정 기다림
      >   * nowait : lock을 획득하지 못하면 바로 exception 처리
      >   * wait integer : 숫자만큼 기다렸다가 lock을 획득하지 못하면 에러 발생
      >   * of + 별칭.컬럼 : 복수 개의 테이블 조인 결과 셋에서 특정 컬럼을 포함한 테이블에 대한 lock을 획득
      >   * skip locked : lock 걸려 있는 레코드를 제외한 나버지 레코드에 lock을 획득
      >     * 세션1
            SELECT * FROM EMP
            WHERE EMP_NO = '7934'
             FOR UPDATE NOWAIT;
            - 세션2
            SELECT * FROM EMP
             WHERE DEPT_NO = 10
             FOR UPDATE WAIT 5;  <-- 7934 직원을 포함한 부서의 lock 적용
             ERROR at line 1;
             ORA-00054: resource busy and acquire with NOWAIT specified
             이미 lock이 명시적으로 설정된 레코드를 포함한 레코드에 명시적으로 lock을 설정하려고 하면 에러 발생
            SELECT * FROM EMP
            WHERE DEPT_NO = 10
       FOR UPDATE SKIP LOCKED;
      에러가 발생하지 않고 7934 직원을 제외한 부서번호 10을 가진 사용자에 lock 획득          